CEGIS Layer
===========

The **CEGIS Layer** executes a local iterative CEGIS (Counterexample-Guided Inductive Synthesis) loop that fills holes in PatchTemplate using custom enumeration. This is where the actual repair happens.

Overview
--------

The CEGIS Layer takes a PatchTemplate with holes (generated by the Patch Generation Layer) and systematically searches for concrete values that satisfy all oracle checks. The process is:

* **Local**: All iterations run on your machine (no network calls)
* **Deterministic**: Given same inputs and oracles, produces identical results
* **Privacy-preserving**: Manifests never leave machine during synthesis
* **Constraint Learning**: Learns constraints from oracle failures to prune search space

The CEGIS loop consists of 4 main steps that repeat until all oracles pass or a termination condition is met:

1. **Verify**: Run all oracles to collect violations
2. **Extract Constraints**: Extract constraints from violation evidence
3. **Enumerate Candidates**: Enumerate candidates from HoleSpace with constraint pruning
4. **Instantiate & Apply**: Convert candidate to patch and apply to artifact

Key Components
--------------

**Holes and Templates**
   Understanding PatchTemplate, HoleRef, and HoleSpace is essential for the CEGIS Layer.
   See :doc:`holes_and_templates` for details.

**CEGIS Loop**
   The core CEGIS algorithm that iteratively verifies, learns constraints, and enumerates candidates.
   See :doc:`cegis_loop` for the complete workflow.

**Constraints**
   Constraints prune the search space by encoding knowledge about which hole assignments always fail.
   See :doc:`constraints` for constraint types and learning (including counterexamples).

How the CEGIS Layer Works
--------------------------

1. **Input**: Artifact + PatchTemplate + HoleSpace + Oracles
2. **Process**: Iterative CEGIS loop that:

   - Verifies current artifact against oracles
   - Extracts constraints from violations (counterexamples)
   - Enumerates candidates from HoleSpace (respecting constraints)
   - Instantiates template with candidate values
   - Applies patch and re-verifies
3. **Output**: Repaired artifact (all oracles pass) or termination (UNSAT/TIMEOUT)

Key Properties
--------------

**Minimal Token Usage**
   The CEGIS Layer runs locally - no additional LLM calls during enumeration.

**Formal Correctness**
   Synthesized values are **guaranteed** to satisfy all constraints learned from oracle failures.

**Determinism**
   Same inputs always produce same patches (unlike LLM sampling).

**Privacy**
   Synthesis happens locally, no manifest sent to external APIs during enumeration.

**Composability**
   Multiple holes can be filled jointly (constraints can relate multiple holes).

**Debuggability**
   Clear separation between structural reasoning (Patch Generation Layer) and value synthesis (CEGIS Layer).

**Cross-Run Learning**
   Fix Bank stores successful patterns for reuse, including learned constraints.

Performance Considerations
--------------------------

**HoleSpace Size**
   Keep spaces small. Total = ``len(hole1) * len(hole2) * ...``
   Example: 5 holes with 5 values each = 3,125 candidates

**Constraint Pruning**
   Constraints significantly reduce search space
   Example: 1 constraint can prune 50% of candidates

**Fix Bank Warm-Start**
   Reusing learned constraints from Fix Bank can skip many invalid candidates

**Timeout and Budget**
   Set reasonable limits: ``max_candidates=1000``, ``timeout_seconds=60.0``

Components
----------

.. toctree::
   :maxdepth: 1

   holes_and_templates
   cegis_loop
   constraints

Next Steps
----------

* Learn about :doc:`holes_and_templates` for understanding holes and PatchTemplate
* Read :doc:`cegis_loop` for the complete CEGIS loop workflow
* Understand :doc:`constraints` for constraint learning and counterexamples
* Explore :doc:`../patch_generation_layer/index` to see how templates are generated
* See :doc:`../reference/api_reference/core` for implementation details

